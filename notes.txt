Oracle Problem:
cant read or listen data from real world

Oracle: any device that interacts with offchain worldto provide external data or computaion to smart contracts

Hybrid Smart Contracts: decentralized network + decentralized Oracle, have some offchain component

Chainlink, decent oracle networks

Concept          ||      Access      || pub or pvt
mnemonic         ||  All accounts    || pvt
pvt key          ||  1 account       || pvt
public address   ||  none            || public


struct (new)
usage:     People public person = People({favoriteNumber:2, name:"Jane"});

    struct People{
        uint256 favoriteNumber;
        string name;
    }
note: fav gets indexed to 0 and name  to 1,wheneevr obj like this, automatically indexed

red error not compiled
yellow warning compiled

calldata temp non-modifiable
memory temp modifiable
storage perm modifiable

choose test net and then go to chain.link to get test eth for the test net, then change iin the remix to inject and connect and deploy


side note: metamasl can be connected through rainbow wallet
no resource for metamask to next

Overriding functions 
when inherit in another contract and want function with same name to override parent contract ka functiin
1.virtual overriding: add "virtual" to parent function and override to child function

payable function fund
"// set minimum fund amount in usd
        require(msg.value > 1e18, "didnt send enough");"

reverting 
unda an action

// blockchains have no idea whats outside the chain, cant access api etc blah blah
called the ORACLE PROBLEM/ SMART CONTRACT CONNECTIVITY PROBLEM

Blockchain Oracle: an device interactiong with off chain world to get data
cant have 1 central oracle cause not decentralized

Chainlink, modular decentralized oracle network, can be customised

blockchain nodes cant make https or api calls

Chainlink Features:
    Chainlink data feeds: 
        chainlink nodes get data from diff exchanges and data providers
        get that data through network of decentral chainlink nodes
        nodes use meduim to figure out actual price of asset
        then deliver to reference/ pricefeed/ data contract on chain that other smart contracts can use
        then the smart contracts use that info to power thier defi app
    Chainlink VRF: (verifiable randomness function)
    Chainlink Keepers:
        decentralized event driven execution
        listen for event then execute

4.3
Interface is a skeleton of the contract, gives info on fuction but not the body

4.5
DECIMALS WITH MONEY
msg.value : 
    in terms of WEI
    18 decimals needed to be ether
    msg.value / 10^18 = ether
AggregatorV3 latestRoundData:
    8 decimals needed to be usd
    price / 10^8 = usd


4.7
LIBRARIES
    - Cant have state variables, cant send ether
    - all functions internal
    - library LibName{}
    - ` import "./LibName.sol"; `
    - inside contract ` using LibName for uint256; `
    - variable.LibFuncName();

4.8
SAFEMATH
    -need for version 0.7.6 and below
    -after sol mai hi aagya
    -unchecked is used when old way ki tarah act karwana chahate hai
    -unchecked is better for gas price so if youre sure of no over/underflows so use unchecked
 
 4.9
LOOPS
    -same

4.10
RESET AN array
    -just redeclare
    -arrName = new uint[](0);

4.11
SENDING ETH FROM CONTRACT
    - 3 ways, transfer (max 2300 gas), send (max 2300 gas), call (all gas)
    - Transfer: ` payable(msg.sender).transfer(address(this).balance); `
    - if transfer fails, throws error, automatically reverts
    - Send: ` bool sendSuccess = payable(msg.sender).send(address(this).balance);
              require(sendSuccess, "Send Failed");
            `
    - if send fails, returns bool, reverts with the require statement
    - Call: ` (bool callSuccess, bytes memory dataReturned) = payable(msg.sender).call{value : address(this).balance}("")
              require(callSuccess, "Call Failed");
            `
    - if call, returns 2 params, bool and bytes onject that is arrays, bytes gives data since we can call any func from "call"

4.12
CONSTRUCTOR
    - gets called immediety as contract is created

4.13
MODIFIER
    - do whats in modifier then do rest where _; is

4.14
TESTNET Demoing
    - used sepolia
    - can add and then connect new account

4.15
ADVANCED SOLIDITY CONCEPTS
---

4.16
IMMUTIBILITY AND CONSTANT
    - one time set constants can be efficiented to save gas
    - Constant : makes the var a Constant
                    ` uint256 public constant VAR_NAME = 50; `
                    ` constants have all caps w/t _ naming convention `
    - Immutable : makes var contant but when set different than declare
                    uint public immutable i_varName;
                    ` i_varName = 30; `
                    ` i_ naminv convention `

4.17
CUSTOM ERRORS
    - create a custom error instead of using require
    - the output string uses alot of gas since each letter stored individually
    - ` error ErrName(); `
    - ` if(b==0) { revert ErrName();} `

4.18
RECIEVE and FALLBACKS
    - if someone sends eth without calling fund function
    - Recieve: pre existing special function that is called when eth is sent
        contract can have at most one, must have external and payable,
        cant return anything, n0 fiunction keyword
    - FallBack: 
        contract can have at most one, must have external payable or (bytes calldata input) external [payable] returns byte memory
        can be virtual, have modifiers

5.09
COMPILING OUR SOLIDITY
    - we use a js function (example here deploy.js)
    - tool solc-js
    - to set up
        ` yarn add solc `
        ` yarn add solc@0.8.7-fixed `
        ` yarn global add solc@0.8.7-fixed `
    - to compile
        ` yarn solcjs --bin --abi --include-path node-modules/ --base-path . -o . SimpleStorage.sol `
        --bin binary
        --abi abi
        --base-path .  means base path is current folder
        -o .  means we will output the current binary and abi to this folder

5.10
GANACHE and NETWORKS
    -rps : pemote procedure call
        connects us to make api calls and interact with blockchain node
    
5.11
INTRODUCTION TO ETHERS.JS
    - contract factory is something used to deploy contracts


5.12
AWAIT keyword
    - inside async function to wait for a promise to finish